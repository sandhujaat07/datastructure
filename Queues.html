<!DOCTYPE html>
<html>
<head>
    <title></title>
    <style>
        /* Add CSS styles for code formatting and page layout */
        pre {
            background-color: #f0f0f0;
            padding: 10px;
            overflow-x: auto;
        }
    </style>
    </head>
    <body>
        <div class="content">
        <h1>QUEUES</h1>
        <section id="">
            <h2>1. Implement the Operations of Simple Queue in an
                 Integer Array (Insert, Delete, Peek, Isempty, Isfull)</h2>
            <pre><code>
                #include 

                int MAX_QUEUE_SIZE = 10;
                int queue[10];
                int front = -1;
                int rear = -1;
                
                // Function to check if the queue is empty
                int isEmpty() {
                    return front == -1;
                }
                
                // Function to check if the queue is full
                int isFull() {
                    return (rear == MAX_QUEUE_SIZE - 1) && (front == 0) || (rear == front - 1);
                }
                
                // Function to insert an element into the queue
                void insert(int item) {
                    if (isFull()) {
                        printf("Queue is full. Cannot insert.\n");
                    } else {
                        if (front == -1) {
                            front = rear = 0;
                        } else if (rear == MAX_QUEUE_SIZE - 1) {
                            rear = 0;
                        } else {
                            rear++;
                        }
                        queue[rear] = item;
                        printf("Inserted: %d\n", item);
                    }
                }
                
                // Function to delete an element from the queue
                int delete() {
                    int item;
                    if (isEmpty()) {
                        printf("Queue is empty. Cannot delete.\n");
                        return -1;
                    } else {
                        item = queue[front];
                        if (front == rear) {
                            front = rear = -1;
                        } else if (front == MAX_QUEUE_SIZE - 1) {
                            front = 0;
                        } else {
                            front++;
                        }
                        return item;
                    }
                }
                
                // Function to peek at the front element of the queue
                int peek() {
                    if (isEmpty()) {
                        printf("Queue is empty. Cannot peek.\n");
                        return -1;
                    } else {
                        return queue[front];
                    }
                }
                
                int main() {
                    int choice, item;
                
                    while (1) {
                        printf("\nQueue Operations:\n");
                        printf("1. Insert\n");
                        printf("2. Delete\n");
                        printf("3. Peek\n");
                        printf("4. Is Empty\n");
                        printf("5. Is Full\n");
                        printf("6. Exit\n");
                        printf("Enter your choice: ");
                        scanf("%d", &choice);
                
                        switch (choice) {
                            case 1:
                                printf("Enter element to insert: ");
                                scanf("%d", &item);
                                insert(item);
                                break;
                            case 2:
                                item = delete();
                                if (item != -1) {
                                    printf("Deleted: %d\n", item);
                                }
                                break;
                            case 3:
                                item = peek();
                                if (item != -1) {
                                    printf("Front element: %d\n", item);
                                }
                                break;
                            case 4:
                                printf(isEmpty() ? "Queue is empty.\n" : "Queue is not empty.\n");
                                break;
                            case 5:
                                printf(isFull() ? "Queue is full.\n" : "Queue is not full.\n");
                                break;
                            case 6:
                                return 0;
                            default:
                                printf("Invalid choice. Please enter a valid option.\n");
                        }
                    }
                
                    return 0;
                }
            </code></pre>
            <h3>Output</h3>
            <pre><code> 
                Queue Operations:
                1. Insert
                2. Delete
                3. Peek
                4. Is Empty
                5. Is Full
                6. Exit
                Enter your choice: 1
                Enter element to insert: 2
                Inserted: 2
                
                Queue Operations:
                1. Insert
                2. Delete
                3. Peek
                4. Is Empty
                5. Is Full
                6. Exit
                Enter your choice: 1
                Enter element to insert: 6
                Inserted: 6
                
                Queue Operations:
                1. Insert
                2. Delete
                3. Peek
                4. Is Empty
                5. Is Full
                6. Exit
                Enter your choice: 3
                Front element: 2
                
                Queue Operations:
                1. Insert
                2. Delete
                3. Peek
                4. Is Empty
                5. Is Full
                6. Exit
                Enter your choice: 6
                
            </code></pre>
        </section>
        <section id="">
            <h2>2. Implement the Operations of
                 Simple Queue in an String Array (Insert, Delete, Peek, Isempty, Isfull)</h2>
            <pre><code>
                #include 
                    
                int MAX_QUEUE_SIZE = 10;
                char queue[10][50]; // Assuming a maximum string length of 49 characters
                int front = -1;
                int rear = -1;
                
                // Function to check if the queue is empty
                int isEmpty() {
                    return front == -1;
                }
                
                // Function to check if the queue is full
                int isFull() {
                    return (rear == MAX_QUEUE_SIZE - 1) && (front == 0) || (rear == front - 1);
                }
                
                // Function to insert a string into the queue
                void insert(const char* item) {
                    if (isFull()) {
                        printf("Queue is full. Cannot insert.\n");
                    } else {
                        if (front == -1) {
                            front = rear = 0;
                        } else if (rear == MAX_QUEUE_SIZE - 1) {
                            rear = 0;
                        } else {
                            rear++;
                        }
                        strcpy(queue[rear], item);
                        printf("Inserted: %s\n", item);
                    }
                }
                
                // Function to delete a string from the queue
                void delete() {
                    if (isEmpty()) {
                        printf("Queue is empty. Cannot delete.\n");
                    } else {
                        printf("Deleted: %s\n", queue[front]);
                        if (front == rear) {
                            front = rear = -1;
                        } else if (front == MAX_QUEUE_SIZE - 1) {
                            front = 0;
                        } else {
                            front++;
                        }
                    }
                }
                
                // Function to peek at the front element of the queue
                void peek() {
                    if (isEmpty()) {
                        printf("Queue is empty. Cannot peek.\n");
                    } else {
                        printf("Front element: %s\n", queue[front]);
                    }
                }
                
                int main() {
                    int choice;
                    char item[50];
                
                    while (1) {
                        printf("\nQueue Operations:\n");
                        printf("1. Insert\n");
                        printf("2. Delete\n");
                        printf("3. Peek\n");
                        printf("4. Is Empty\n");
                        printf("5. Is Full\n");
                        printf("6. Exit\n");
                        printf("Enter your choice: ");
                        scanf("%d", &choice);
                
                        switch (choice) {
                            case 1:
                                printf("Enter string to insert: ");
                                scanf("%s", item);
                                insert(item);
                                break;
                            case 2:
                                delete();
                                break;
                            case 3:
                                peek();
                                break;
                            case 4:
                                printf(isEmpty() ? "Queue is empty.\n" : "Queue is not empty.\n");
                                break;
                            case 5:
                                printf(isFull() ? "Queue is full.\n" : "Queue is not full.\n");
                                break;
                            case 6:
                                return 0;
                            default:
                                printf("Invalid choice. Please enter a valid option.\n");
                        }
                    }
                
                    return 0;
                }
                
        
            </code></pre>
            <h3>Output</h3>
            <pre><code> 
                Queue Operations:
                1. Insert
                2. Delete
                3. Peek
                4. Is Empty
                5. Is Full
                6. Exit
                Enter your choice: 1
                Enter string to insert: 6
                Inserted: 6
                
                Queue Operations:
                1. Insert
                2. Delete
                3. Peek
                4. Is Empty
                5. Is Full
                6. Exit
                Enter your choice: 1
                Enter string to insert: 5
                Inserted: 5
                
                Queue Operations:
                1. Insert
                2. Delete
                3. Peek
                4. Is Empty
                5. Is Full
                6. Exit
                Enter your choice: 2
                Deleted: 6
                
                Queue Operations:
                1. Insert
                2. Delete
                3. Peek
                4. Is Empty
                5. Is Full
                6. Exit
                Enter your choice: 3
                Front element: 5
                
          
            </code></pre>
        </section>
        <section id="">
            <h2></h2>3. Implement the Operations of Queue Dynamically
             of Integers (Insert, Delete, Peek, Isempty, Isfull)
            <pre><code>
                #include 
                    
                // Structure for a queue node
                struct QueueNode {
                    int data;
                    struct QueueNode* next;
                };
                
                // Structure for a dynamic queue
                struct DynamicQueue {
                    struct QueueNode* front;
                    struct QueueNode* rear;
                };
                
                // Function to create a new queue
                struct DynamicQueue* createQueue() {
                    struct DynamicQueue* queue = (struct DynamicQueue*)malloc(sizeof(struct DynamicQueue));
                    if (queue == NULL) {
                        printf("Memory allocation error. Cannot create the queue.\n");
                        exit(1);
                    }
                    queue->front = queue->rear = NULL;
                    return queue;
                }
                
                // Function to check if the queue is empty
                int isEmpty(struct DynamicQueue* queue) {
                    return queue->front == NULL;
                }
                
                // Function to insert an element into the queue
                void insert(struct DynamicQueue* queue, int item) {
                    struct QueueNode* newNode = (struct QueueNode*)malloc(sizeof(struct QueueNode));
                    if (newNode == NULL) {
                        printf("Memory allocation error. Cannot insert the element.\n");
                        exit(1);
                    }
                    newNode->data = item;
                    newNode->next = NULL;
                    if (isEmpty(queue)) {
                        queue->front = queue->rear = newNode;
                    } else {
                        queue->rear->next = newNode;
                        queue->rear = newNode;
                    }
                    printf("Inserted: %d\n", item);
                }
                
                // Function to delete an element from the queue
                int delete(struct DynamicQueue* queue) {
                    if (isEmpty(queue)) {
                        printf("Queue is empty. Cannot delete.\n");
                        return -1;
                    }
                    struct QueueNode* temp = queue->front;
                    int item = temp->data;
                    queue->front = temp->next;
                    free(temp);
                    return item;
                }
                
                // Function to peek at the front element of the queue
                int peek(struct DynamicQueue* queue) {
                    if (isEmpty(queue)) {
                        printf("Queue is empty. Cannot peek.\n");
                        return -1;
                    }
                    return queue->front->data;
                }
                
                int main() {
                    struct DynamicQueue* queue = createQueue();
                    int choice, item;
                
                    while (1) {
                        printf("\nQueue Operations:\n");
                        printf("1. Insert\n");
                        printf("2. Delete\n");
                        printf("3. Peek\n");
                        printf("4. Is Empty\n");
                        printf("5. Exit\n");
                        printf("Enter your choice: ");
                        scanf("%d", &choice);
                
                        switch (choice) {
                            case 1:
                                printf("Enter element to insert: ");
                                scanf("%d", &item);
                                insert(queue, item);
                                break;
                            case 2:
                                item = delete(queue);
                                if (item != -1) {
                                    printf("Deleted: %d\n", item);
                                }
                                break;
                            case 3:
                                item = peek(queue);
                                if (item != -1) {
                                    printf("Front element: %d\n", item);
                                }
                                break;
                            case 4:
                                printf(isEmpty(queue) ? "Queue is empty.\n" : "Queue is not empty.\n");
                                break;
                            case 5:
                                return 0;
                            default:
                                printf("Invalid choice. Please enter a valid option.\n");
                        }
                    }
                
                    return 0;
                }
          
            </code></pre>
            <h3>Output</h3>
            <pre><code> 
                Queue Operations:
                1. Insert
                2. Delete
                3. Peek
                4. Is Empty
                5. Exit
                Enter your choice: 1
                Enter element to insert: 6
                Inserted: 6
                
                Queue Operations:
                1. Insert
                2. Delete
                3. Peek
                4. Is Empty
                5. Exit
                Enter your choice: 1
                Enter element to insert: 8
                Inserted: 8
                
            </code></pre>
        </section>
        <section id="">
            <h2>4. Implement the Operations of Queue
                 Dynamically of String (Insert, Delete, Peek, Isempty, Isfull)</h2>
            <pre><code>
                #include 
                #include 
                
                // Structure for a queue node
                struct QueueNode {
                    char data[50]; // Assuming a maximum string length of 49 characters
                    struct QueueNode* next;
                };
                
                // Structure for a dynamic queue
                struct DynamicQueue {
                    struct QueueNode* front;
                    struct QueueNode* rear;
                };
                
                // Function to create a new queue
                struct DynamicQueue* createQueue() {
                    struct DynamicQueue* queue = (struct DynamicQueue*)malloc(sizeof(struct DynamicQueue));
                    if (queue == NULL) {
                        printf("Memory allocation error. Cannot create the queue.\n");
                        exit(1);
                    }
                    queue->front = queue->rear = NULL;
                    return queue;
                }
                
                // Function to check if the queue is empty
                int isEmpty(struct DynamicQueue* queue) {
                    return queue->front == NULL;
                }
                
                // Function to insert a string into the queue
                void insert(struct DynamicQueue* queue, const char* item) {
                    struct QueueNode* newNode = (struct QueueNode*)malloc(sizeof(struct QueueNode));
                    if (newNode == NULL) {
                        printf("Memory allocation error. Cannot insert the element.\n");
                        exit(1);
                    }
                    strncpy(newNode->data, item, 49); // Ensure the string is null-terminated
                    newNode->next = NULL;
                    if (isEmpty(queue)) {
                        queue->front = queue->rear = newNode;
                    } else {
                        queue->rear->next = newNode;
                        queue->rear = newNode;
                    }
                    printf("Inserted: %s\n", item);
                }
                
                // Function to delete a string from the queue
                char* delete(struct DynamicQueue* queue) {
                    if (isEmpty(queue)) {
                        printf("Queue is empty. Cannot delete.\n");
                        return NULL;
                    }
                    struct QueueNode* temp = queue->front;
                    char* item = (char*)malloc(strlen(temp->data) + 1); // +1 for null-terminator
                    if (item == NULL) {
                        printf("Memory allocation error. Cannot delete the element.\n");
                        exit(1);
                    }
                    strcpy(item, temp->data);
                    queue->front = temp->next;
                    free(temp);
                    return item;
                }
                
                // Function to peek at the front element of the queue
                char* peek(struct DynamicQueue* queue) {
                    if (isEmpty(queue)) {
                        printf("Queue is empty. Cannot peek.\n");
                        return NULL;
                    }
                    char* item = (char*)malloc(strlen(queue->front->data) + 1); // +1 for null-terminator
                    if (item == NULL) {
                        printf("Memory allocation error. Cannot peek the element.\n");
                        exit(1);
                    }
                    strcpy(item, queue->front->data);
                    return item;
                }
                
                int main() {
                    struct DynamicQueue* queue = createQueue();
                    int choice;
                    char item[50];
                
                    while (1) {
                        printf("\nQueue Operations:\n");
                        printf("1. Insert\n");
                        printf("2. Delete\n");
                        printf("3. Peek\n");
                        printf("4. Is Empty\n");
                        printf("5. Exit\n");
                        printf("Enter your choice: ");
                        scanf("%d", &choice);
                
                        switch (choice) {
                            case 1:
                                printf("Enter string to insert: ");
                                scanf("%s", item);
                                insert(queue, item);
                                break;
                            case 2:
                                char* deletedItem = delete(queue);
                                if (deletedItem != NULL) {
                                    printf("Deleted: %s\n", deletedItem);
                                    free(deletedItem);
                                }
                                break;
                            case 3:
                                char* peekedItem = peek(queue);
                                if (peekedItem != NULL) {
                                    printf("Front element: %s\n", peekedItem);
                                    free(peekedItem);
                                }
                                break;
                            case 4:
                                printf(isEmpty(queue) ? "Queue is empty.\n" : "Queue is not empty.\n");
                                break;
                            case 5:
                                return 0;
                            default:
                                printf("Invalid choice. Please enter a valid option.\n");
                        }
                    }
                
                    return 0;
                }
              
            </code></pre>
            <h3>Output</h3>
            <pre><code> 
                Queue Operations:
                1. Insert
                2. Delete
                3. Peek
                4. Is Empty
                5. Exit
                Enter your choice: 1
                Enter string to insert: K
                Inserted: K
                
                Queue Operations:
                1. Insert
                2. Delete
                3. Peek
                4. Is Empty
                5. Exit
                Enter your choice: 1
                Enter string to insert: J
                Inserted: J
                
                Queue Operations:
                1. Insert
                2. Delete
                3. Peek
                4. Is Empty
                5. Exit
                Enter your choice: 3
                Front element: K
                
            </code></pre>
        </section>
        <section id="">
            <h2>5. Implement the Operations of Circular Queue in an Integer Array (Insert, Delete, Peek, Isempty, Isfull)
            </h2>
            <pre><code>
                #include 
                    
                int MAX_QUEUE_SIZE = 10; // Maximum queue size
                int* circularQueue;
                int front = -1;
                int rear = -1;
                
                // Function to check if the queue is empty
                int isEmpty() {
                    return (front == -1 && rear == -1);
                }
                
                // Function to check if the queue is full
                int isFull() {
                    return ((rear + 1) % MAX_QUEUE_SIZE) == front;
                }
                
                // Function to insert an element into the circular queue
                void insert(int item) {
                    if (isFull()) {
                        printf("Queue is full. Cannot insert.\n");
                    } else {
                        if (isEmpty()) {
                            front = rear = 0;
                        } else {
                            rear = (rear + 1) % MAX_QUEUE_SIZE;
                        }
                        circularQueue[rear] = item;
                        printf("Inserted: %d\n", item);
                    }
                }
                
                // Function to delete an element from the circular queue
                int delete() {
                    if (isEmpty()) {
                        printf("Queue is empty. Cannot delete.\n");
                        return -1;
                    } else {
                        int item = circularQueue[front];
                        if (front == rear) {
                            front = rear = -1;
                        } else {
                            front = (front + 1) % MAX_QUEUE_SIZE;
                        }
                        return item;
                    }
                }
                
                // Function to peek at the front element of the circular queue
                int peek() {
                    if (isEmpty()) {
                        printf("Queue is empty. Cannot peek.\n");
                        return -1;
                    } else {
                        return circularQueue[front];
                    }
                }
                
                int main() {
                    circularQueue = (int*)malloc(MAX_QUEUE_SIZE * sizeof(int));
                
                    int choice, item;
                
                    while (1) {
                        printf("\nCircular Queue Operations:\n");
                        printf("1. Insert\n");
                        printf("2. Delete\n");
                        printf("3. Peek\n");
                        printf("4. Is Empty\n");
                        printf("5. Is Full\n");
                        printf("6. Exit\n");
                        printf("Enter your choice: ");
                        scanf("%d", &choice);
                
                        switch (choice) {
                            case 1:
                                printf("Enter element to insert: ");
                                scanf("%d", &item);
                                insert(item);
                                break;
                            case 2:
                                item = delete();
                                if (item != -1) {
                                    printf("Deleted: %d\n", item);
                                }
                                break;
                            case 3:
                                item = peek();
                                if (item != -1) {
                                    printf("Front element: %d\n", item);
                                }
                                break;
                            case 4:
                                printf(isEmpty() ? "Queue is empty.\n" : "Queue is not empty.\n");
                                break;
                            case 5:
                                printf(isFull() ? "Queue is full.\n" : "Queue is not full.\n");
                                break;
                            case 6:
                                free(circularQueue);
                                return 0;
                            default:
                                printf("Invalid choice. Please enter a valid option.\n");
                        }
                    }
                
                    free(circularQueue);
                    return 0;
                }
                
        
            </code></pre>
            <h3>Output</h3>
            <pre><code> 
                Circular Queue Operations:
                1. Insert
                2. Delete
                3. Peek
                4. Is Empty
                5. Is Full
                6. Exit
                Enter your choice: 1
                Enter element to insert: 3
                Inserted: 3
                
                Circular Queue Operations:
                1. Insert
                2. Delete
                3. Peek
                4. Is Empty
                5. Is Full
                6. Exit
                Enter your choice: 1
                Enter element to insert: 4
                Inserted: 4
                
            </code></pre>
        </section>
        <section id="">
            <h2>6. Implement the Operations of Circular Queue 
                in an String Array (Insert, Delete, Peek, Isempty, Isfull)</h2>
            <pre><code>
                #include 
                #include 
                #include 
                
                int MAX_QUEUE_SIZE = 10; // Maximum queue size
                char** circularQueue;
                int front = -1;
                int rear = -1;
                
                // Function to check if the queue is empty
                int isEmpty() {
                    return (front == -1 && rear == -1);
                }
                
                // Function to check if the queue is full
                int isFull() {
                    return ((rear + 1) % MAX_QUEUE_SIZE) == front;
                }
                
                // Function to insert a string into the circular queue
                void insert(const char* item) {
                    if (isFull()) {
                        printf("Queue is full. Cannot insert.\n");
                    } else {
                        if (isEmpty()) {
                            front = rear = 0;
                        } else {
                            rear = (rear + 1) % MAX_QUEUE_SIZE;
                        }
                        circularQueue[rear] = (char*)malloc(strlen(item) + 1); // +1 for null-terminator
                        if (circularQueue[rear] == NULL) {
                            printf("Memory allocation error. Cannot insert the element.\n");
                            exit(1);
                        }
                        strcpy(circularQueue[rear], item);
                        printf("Inserted: %s\n", item);
                    }
                }
                
                // Function to delete a string from the circular queue
                char* delete() {
                    if (isEmpty()) {
                        printf("Queue is empty. Cannot delete.\n");
                        return NULL;
                    } else {
                        char* item = circularQueue[front];
                        if (front == rear) {
                            front = rear = -1;
                        } else {
                            front = (front + 1) % MAX_QUEUE_SIZE;
                        }
                        return item;
                    }
                }
                
                // Function to peek at the front element of the circular queue
                char* peek() {
                    if (isEmpty()) {
                        printf("Queue is empty. Cannot peek.\n");
                        return NULL;
                    } else {
                        return circularQueue[front];
                    }
                }
                
                int main() {
                    circularQueue = (char**)malloc(MAX_QUEUE_SIZE * sizeof(char*));
                
                    int choice;
                    char item[50];
                
                    while (1) {
                        printf("\nCircular Queue Operations:\n");
                        printf("1. Insert\n");
                        printf("2. Delete\n");
                        printf("3. Peek\n");
                        printf("4. Is Empty\n");
                        printf("5. Is Full\n");
                        printf("6. Exit\n");
                        printf("Enter your choice: ");
                        scanf("%d", &choice);
                
                        switch (choice) {
                            case 1:
                                printf("Enter string to insert: ");
                                scanf("%s", item);
                                insert(item);
                                break;
                            case 2:
                                char* deletedItem = delete();
                                if (deletedItem != NULL) {
                                    printf("Deleted: %s\n", deletedItem);
                                    free(deletedItem);
                                }
                                break;
                            case 3:
                                char* peekedItem = peek();
                                if (peekedItem != NULL) {
                                    printf("Front element: %s\n", peekedItem);
                                }
                                break;
                            case 4:
                                printf(isEmpty() ? "Queue is empty.\n" : "Queue is not empty.\n");
                                break;
                            case 5:
                                printf(isFull() ? "Queue is full.\n" : "Queue is not full.\n");
                                break;
                            case 6:
                                for (int i = 0; i < MAX_QUEUE_SIZE; i++) {
                                    if (circularQueue[i] != NULL) {
                                        free(circularQueue[i]);
                                    }
                                }
                                free(circularQueue);
                                return 0;
                            default:
                                printf("Invalid choice. Please enter a valid option.\n");
                        }
                    }
                
                    return 0;
                }
                
            </code></pre>
            <h3>Output</h3>
            <pre><code> 
                Circular Queue Operations:
                1. Insert
                2. Delete
                3. Peek
                4. Is Empty
                5. Is Full
                6. Exit
                Enter your choice: 1
                Enter string to insert: P
                Inserted: P
                
                Circular Queue Operations:
                1. Insert
                2. Delete
                3. Peek
                4. Is Empty
                5. Is Full
                6. Exit
                Enter your choice: 1
                Enter string to insert: R
                Inserted: R
                
            </code></pre>
        </section>
        <section id="">
            <h2>7.  Implement the Operations of Priority Queue in an Integer Array (Insert, Delete, Peek, Isempty, Isfull)
            </h2>
            <pre><code>
                #include 
                #include 
                
                int MAX_QUEUE_SIZE = 10; // Maximum queue size
                int* priorityQueue;
                int rear = -1;
                
                // Function to check if the priority queue is empty
                int isEmpty() {
                    return rear == -1;
                }
                
                // Function to check if the priority queue is full
                int isFull() {
                    return rear == MAX_QUEUE_SIZE - 1;
                }
                
                // Function to insert an element into the priority queue
                void insert(int item) {
                    if (isFull()) {
                        printf("Queue is full. Cannot insert.\n");
                    } else {
                        int i;
                        for (i = rear; i >= 0; i--) {
                            if (item > priorityQueue[i]) {
                                priorityQueue[i + 1] = priorityQueue[i];
                            } else {
                                break;
                            }
                        }
                        priorityQueue[i + 1] = item;
                        rear++;
                        printf("Inserted: %d\n", item);
                    }
                }
                
                // Function to delete the element with the highest priority
                int delete() {
                    if (isEmpty()) {
                        printf("Queue is empty. Cannot delete.\n");
                        return -1;
                    } else {
                        int item = priorityQueue[rear];
                        rear--;
                        return item;
                    }
                }
                
                // Function to peek at the highest-priority element
                int peek() {
                    if (isEmpty()) {
                        printf("Queue is empty. Cannot peek.\n");
                        return -1;
                    } else {
                        return priorityQueue[rear];
                    }
                }
                
                int main() {
                    priorityQueue = (int*)malloc(MAX_QUEUE_SIZE * sizeof(int));
                
                    int choice, item;
                
                    while (1) {
                        printf("\nPriority Queue Operations:\n");
                        printf("1. Insert\n");
                        printf("2. Delete\n");
                        printf("3. Peek\n");
                        printf("4. Is Empty\n");
                        printf("5. Is Full\n");
                        printf("6. Exit\n");
                        printf("Enter your choice: ");
                        scanf("%d", &choice);
                
                        switch (choice) {
                            case 1:
                                printf("Enter element to insert: ");
                                scanf("%d", &item);
                                insert(item);
                                break;
                            case 2:
                                item = delete();
                                if (item != -1) {
                                    printf("Deleted: %d\n", item);
                                }
                                break;
                            case 3:
                                item = peek();
                                if (item != -1) {
                                    printf("Highest-priority element: %d\n", item);
                                }
                                break;
                            case 4:
                                printf(isEmpty() ? "Queue is empty.\n" : "Queue is not empty.\n");
                                break;
                            case 5:
                                printf(isFull() ? "Queue is full.\n" : "Queue is not full.\n");
                                break;
                            case 6:
                                free(priorityQueue);
                                return 0;
                            default:
                                printf("Invalid choice. Please enter a valid option.\n");
                        }
                    }
                
                    free(priorityQueue);
                    return 0;
                }
                
            </code></pre>
            <h3>Output</h3>
            <pre><code> 
                Priority Queue Operations:
                1. Insert
                2. Delete
                3. Peek
                4. Is Empty
                5. Is Full
                6. Exit
                Enter your choice: 1
                Enter element to insert: 7
                Inserted: 7
                
                Priority Queue Operations:
                1. Insert
                2. Delete
                3. Peek
                4. Is Empty
                5. Is Full
                6. Exit
                Enter your choice: 1
                Enter element to insert: 8
                Inserted: 8
                
                Priority Queue Operations:
                1. Insert
                2. Delete
                3. Peek
                4. Is Empty
                5. Is Full
                6. Exit
                Enter your choice: 3
                Highest-priority element: 7
                
            </code></pre>
        </section>
        <section id="">
            <h2>8. Implement the Operations of Priority Queue in an String Array (Insert, Delete, Peek, Isempty, Isfull)
            </h2>
            <pre><code>
                #include 
                #include 
                
                int MAX_QUEUE_SIZE = 10; // Maximum queue size
                int* priorityQueue;
                int rear = -1;
                
                // Function to check if the priority queue is empty
                int isEmpty() {
                    return rear == -1;
                }
                
                // Function to check if the priority queue is full
                int isFull() {
                    return rear == MAX_QUEUE_SIZE - 1;
                }
                
                // Function to insert an element into the priority queue
                void insert(int item) {
                    if (isFull()) {
                        printf("Queue is full. Cannot insert.\n");
                    } else {
                        int i;
                        for (i = rear; i >= 0; i--) {
                            if (item > priorityQueue[i]) {
                                priorityQueue[i + 1] = priorityQueue[i];
                            } else {
                                break;
                            }
                        }
                        priorityQueue[i + 1] = item;
                        rear++;
                        printf("Inserted: %d\n", item);
                    }
                }
                
                // Function to delete the element with the highest priority
                int delete() {
                    if (isEmpty()) {
                        printf("Queue is empty. Cannot delete.\n");
                        return -1;
                    } else {
                        int item = priorityQueue[rear];
                        rear--;
                        return item;
                    }
                }
                
                // Function to peek at the highest-priority element
                int peek() {
                    if (isEmpty()) {
                        printf("Queue is empty. Cannot peek.\n");
                        return -1;
                    } else {
                        return priorityQueue[rear];
                    }
                }
                
                int main() {
                    priorityQueue = (int*)malloc(MAX_QUEUE_SIZE * sizeof(int));
                
                    int choice, item;
                
                    while (1) {
                        printf("\nPriority Queue Operations:\n");
                        printf("1. Insert\n");
                        printf("2. Delete\n");
                        printf("3. Peek\n");
                        printf("4. Is Empty\n");
                        printf("5. Is Full\n");
                        printf("6. Exit\n");
                        printf("Enter your choice: ");
                        scanf("%d", &choice);
                
                        switch (choice) {
                            case 1:
                                printf("Enter element to insert: ");
                                scanf("%d", &item);
                                insert(item);
                                break;
                            case 2:
                                item = delete();
                                if (item != -1) {
                                    printf("Deleted: %d\n", item);
                                }
                                break;
                            case 3:
                                item = peek();
                                if (item != -1) {
                                    printf("Highest-priority element: %d\n", item);
                                }
                                break;
                            case 4:
                                printf(isEmpty() ? "Queue is empty.\n" : "Queue is not empty.\n");
                                break;
                            case 5:
                                printf(isFull() ? "Queue is full.\n" : "Queue is not full.\n");
                                break;
                            case 6:
                                free(priorityQueue);
                                return 0;
                            default:
                                printf("Invalid choice. Please enter a valid option.\n");
                        }
                    }
                
                    free(priorityQueue);
                    return 0;
                }
            </code></pre>
            <h3>Output</h3>
            <pre><code> 
                Priority Queue Operations:
                1. Insert
                2. Delete
                3. Peekx
                4. Is Empty
                5. Is Full
                6. Exit
                Enter your choice: 1
                Enter element to insert: 5
                Inserted: 5
                
                Priority Queue Operations:
                1. Insert
                2. Delete
                3. Peek
                4. Is Empty
                5. Is Full
                6. Exit
                Enter your choice: 1
                Enter element to insert: 8
                Inserted: 8
                
                Priority Queue Operations:
                1. Insert
                2. Delete
                3. Peek
                4. Is Empty
                5. Is Full
                6. Exit
                Enter your choice: 3
                Highest-priority element: 5
                
                Priority Queue Operations:
                1. Insert
                2. Delete
                3. Peek
                4. Is Empty
                5. Is Full
                6. Exit
                Enter your choice: 4
                Queue is not empty.
                
                Priority Queue Operations:
                1. Insert
                2. Delete
                3. Peek
                4. Is Empty
                5. Is Full
                6. Exit
                Enter your choice: 6
                
            
            </code></pre>
        </section>
        <section id="">
            <h2>9. Implement the Operations of Double Ended Queue in an Integer Array (Insert, Delete, Peek, Isempty, Isfull)
            </h2>
            <pre><code>
                #include 
                #include 
                
                int MAX_QUEUE_SIZE = 10; // Maximum deque size
                int* deque;
                int front = -1;
                int rear = -1;
                
                // Function to check if the deque is empty
                int isEmpty() {
                    return front == -1;
                }
                
                // Function to check if the deque is full
                int isFull() {
                    return (front == 0 && rear == MAX_QUEUE_SIZE - 1) || (front == rear + 1);
                }
                
                // Function to insert an element at the front of the deque
                void insertFront(int item) {
                    if (isFull()) {
                        printf("Deque is full. Cannot insert at the front.\n");
                    } else {
                        if (front == -1) {
                            front = rear = 0;
                        } else if (front == 0) {
                            front = MAX_QUEUE_SIZE - 1;
                        } else {
                            front -= 1;
                        }
                        deque[front] = item;
                        printf("Inserted at the front: %d\n", item);
                    }
                }
                
                // Function to insert an element at the rear of the deque
                void insertRear(int item) {
                    if (isFull()) {
                        printf("Deque is full. Cannot insert at the rear.\n");
                    } else {
                        if (front == -1) {
                            front = rear = 0;
                        } else if (rear == MAX_QUEUE_SIZE - 1) {
                            rear = 0;
                        } else {
                            rear += 1;
                        }
                        deque[rear] = item;
                        printf("Inserted at the rear: %d\n", item);
                    }
                }
                
                // Function to delete an element from the front of the deque
                int deleteFront() {
                    if (isEmpty()) {
                        printf("Deque is empty. Cannot delete from the front.\n");
                        return -1;
                    } else {
                        int item = deque[front];
                        if (front == rear) {
                            front = rear = -1;
                        } else if (front == MAX_QUEUE_SIZE - 1) {
                            front = 0;
                        } else {
                            front += 1;
                        }
                        return item;
                    }
                }
                
                // Function to delete an element from the rear of the deque
                int deleteRear() {
                    if (isEmpty()) {
                        printf("Deque is empty. Cannot delete from the rear.\n");
                        return -1;
                    } else {
                        int item = deque[rear];
                        if (front == rear) {
                            front = rear = -1;
                        } else if (rear == 0) {
                            rear = MAX_QUEUE_SIZE - 1;
                        } else {
                            rear -= 1;
                        }
                        return item;
                    }
                }
                
                // Function to peek at the front element of the deque
                int peekFront() {
                    if (isEmpty()) {
                        printf("Deque is empty. Cannot peek at the front.\n");
                        return -1;
                    } else {
                        return deque[front];
                    }
                }
                
                // Function to peek at the rear element of the deque
                int peekRear() {
                    if (isEmpty()) {
                        printf("Deque is empty. Cannot peek at the rear.\n");
                        return -1;
                    } else {
                        return deque[rear];
                    }
                }
                
                int main() {
                    deque = (int*)malloc(MAX_QUEUE_SIZE * sizeof(int));
                
                    int choice, item;
                
                    while (1) {
                        printf("\nDouble Ended Queue (Deque) Operations:\n");
                        printf("1. Insert at Front\n");
                        printf("2. Insert at Rear\n");
                        printf("3. Delete from Front\n");
                        printf("4. Delete from Rear\n");
                        printf("5. Peek at Front\n");
                        printf("6. Peek at Rear\n");
                        printf("7. Is Empty\n");
                        printf("8. Is Full\n");
                        printf("9. Exit\n");
                        printf("Enter your choice: ");
                        scanf("%d", &choice);
                
                        switch (choice) {
                            case 1:
                                printf("Enter element to insert at the front: ");
                                scanf("%d", &item);
                                insertFront(item);
                                break;
                            case 2:
                                printf("Enter element to insert at the rear: ");
                                scanf("%d", &item);
                                insertRear(item);
                                break;
                            case 3:
                                item = deleteFront();
                                if (item != -1) {
                                    printf("Deleted from the front: %d\n", item);
                                }
                                break;
                            case 4:
                                item = deleteRear();
                                if (item != -1) {
                                    printf("Deleted from the rear: %d\n", item);
                                }
                                break;
                            case 5:
                                item = peekFront();
                                if (item != -1) {
                                    printf("Front element: %d\n", item);
                                }
                                break;
                            case 6:
                                item = peekRear();
                                if (item != -1) {
                                    printf("Rear element: %d\n", item);
                                }
                                break;
                            case 7:
                                printf(isEmpty() ? "Deque is empty.\n" : "Deque is not empty.\n");
                                break;
                            case 8:
                                printf(isFull() ? "Deque is full.\n" : "Deque is not full.\n");
                                break;
                            case 9:
                                free(deque);
                                return 0;
                            default:
                                printf("Invalid choice. Please enter a valid option.\n");
                        }
                    }
                
                    free(deque);
                    return 0;
                }
                
      
            </code></pre>
            <h3>Output</h3>
            <pre><code> 
                Double Ended Queue (Deque) Operations:
                1. Insert at Front
                2. Insert at Rear
                3. Delete from Front
                4. Delete from Rear
                5. Peek at Front
                6. Peek at Rear
                7. Is Empty
                8. Is Full
                9. Exit
                Enter your choice: 1
                Enter element to insert at the front: 11
                Inserted at the front: 11
                
                Double Ended Queue (Deque) Operations:
                1. Insert at Front
                2. Insert at Rear
                3. Delete from Front
                4. Delete from Rear
                5. Peek at Front
                6. Peek at Rear
                7. Is Empty
                8. Is Full
                9. Exit
                Enter your choice: 2
                Enter element to insert at the rear: 22
                Inserted at the rear: 22
                
                Double Ended Queue (Deque) Operations:
                1. Insert at Front
                2. Insert at Rear
                3. Delete from Front
                4. Delete from Rear
                5. Peek at Front
                6. Peek at Rear
                7. Is Empty
                8. Is Full
                9. Exit
                Enter your choice: 1
                Enter element to insert at the front: 15
                Inserted at the front: 15
                
                Double Ended Queue (Deque) Operations:
                1. Insert at Front
                2. Insert at Rear
                3. Delete from Front
                4. Delete from Rear
                5. Peek at Front
                6. Peek at Rear
                7. Is Empty
                8. Is Full
                9. Exit
                Enter your choice: 5
                Front element: 15
                
                Double Ended Queue (Deque) Operations:
                1. Insert at Front
                2. Insert at Rear
                3. Delete from Front
                4. Delete from Rear
                5. Peek at Front
                6. Peek at Rear
                7. Is Empty
                8. Is Full
                9. Exit
                Enter your choice: 6
                Rear element: 22
                
                Double Ended Queue (Deque) Operations:
                1. Insert at Front
                2. Insert at Rear
                3. Delete from Front
                4. Delete from Rear
                5. Peek at Front
                6. Peek at Rear
                7. Is Empty
                8. Is Full
                9. Exit
                Enter your choice: 8
                Deque is not full.
                
            </code></pre>
        </section>
        <section id="">
            <h2>10. Implement the Operations of Double Ended Queue in an String Array (Insert, Delete, Peek, Isempty, Isfull)
            </h2>
            <pre><code>
                #include 
                #include 
                #include 
                
                int MAX_QUEUE_SIZE = 10; // Maximum deque size
                char** deque;
                int front = -1;
                int rear = -1;
                
                // Function to check if the deque is empty
                int isEmpty() {
                    return front == -1;
                }
                
                // Function to check if the deque is full
                int isFull() {
                    return (front == 0 && rear == MAX_QUEUE_SIZE - 1) || (front == rear + 1);
                }
                
                // Function to insert a string at the front of the deque
                void insertFront(char* item) {
                    if (isFull()) {
                        printf("Deque is full. Cannot insert at the front.\n");
                    } else {
                        if (front == -1) {
                            front = rear = 0;
                        } else if (front == 0) {
                            front = MAX_QUEUE_SIZE - 1;
                        } else {
                            front -= 1;
                        }
                        deque[front] = strdup(item); // Duplicate the input string
                        printf("Inserted at the front: %s\n", item);
                    }
                }
                
                // Function to insert a string at the rear of the deque
                void insertRear(char* item) {
                    if (isFull()) {
                        printf("Deque is full. Cannot insert at the rear.\n");
                    } else {
                        if (front == -1) {
                            front = rear = 0;
                        } else if (rear == MAX_QUEUE_SIZE - 1) {
                            rear = 0;
                        } else {
                            rear += 1;
                        }
                        deque[rear] = strdup(item); // Duplicate the input string
                        printf("Inserted at the rear: %s\n", item);
                    }
                }
                
                // Function to delete a string from the front of the deque
                char* deleteFront() {
                    if (isEmpty()) {
                        printf("Deque is empty. Cannot delete from the front.\n");
                        return NULL;
                    } else {
                        char* item = deque[front];
                        if (front == rear) {
                            front = rear = -1;
                        } else if (front == MAX_QUEUE_SIZE - 1) {
                            front = 0;
                        } else {
                            front += 1;
                        }
                        return item;
                    }
                }
                
                // Function to delete a string from the rear of the deque
                char* deleteRear() {
                    if (isEmpty()) {
                        printf("Deque is empty. Cannot delete from the rear.\n");
                        return NULL;
                    } else {
                        char* item = deque[rear];
                        if (front == rear) {
                            front = rear = -1;
                        } else if (rear == 0) {
                            rear = MAX_QUEUE_SIZE - 1;
                        } else {
                            rear -= 1;
                        }
                        return item;
                    }
                }
                
                // Function to peek at the front string of the deque
                char* peekFront() {
                    if (isEmpty()) {
                        printf("Deque is empty. Cannot peek at the front.\n");
                        return NULL;
                    } else {
                        return deque[front];
                    }
                }
                
                // Function to peek at the rear string of the deque
                char* peekRear() {
                    if (isEmpty()) {
                        printf("Deque is empty. Cannot peek at the rear.\n");
                        return NULL;
                    } else {
                        return deque[rear];
                    }
                }
                
                int main() {
                    deque = (char**)malloc(MAX_QUEUE_SIZE * sizeof(char*));
                
                    int choice;
                    char input[100];
                
                    while (1) {
                        printf("\nDouble Ended Queue (Deque) Operations:\n");
                        printf("1. Insert at Front\n");
                        printf("2. Insert at Rear\n");
                        printf("3. Delete from Front\n");
                        printf("4. Delete from Rear\n");
                        printf("5. Peek at Front\n");
                        printf("6. Peek at Rear\n");
                        printf("7. Is Empty\n");
                        printf("8. Is Full\n");
                        printf("9. Exit\n");
                        printf("Enter your choice: ");
                        scanf("%d", &choice);
                
                        switch (choice) {
                            case 1:
                                printf("Enter a string to insert at the front: ");
                                scanf("%s", input);
                                insertFront(input);
                                break;
                            case 2:
                                printf("Enter a string to insert at the rear: ");
                                scanf("%s", input);
                                insertRear(input);
                                break;
                            case 3:
                                char* deletedFront = deleteFront();
                                if (deletedFront != NULL) {
                                    printf("Deleted from the front: %s\n", deletedFront);
                                    free(deletedFront);
                                }
                                break;
                            case 4:
                                char* deletedRear = deleteRear();
                                if (deletedRear != NULL) {
                                    printf("Deleted from the rear: %s\n", deletedRear);
                                    free(deletedRear);
                                }
                                break;
                            case 5:
                                char* frontStr = peekFront();
                                if (frontStr != NULL) {
                                    printf("Front element: %s\n", frontStr);
                                }
                                break;
                            case 6:
                                char* rearStr = peekRear();
                                if (rearStr != NULL) {
                                    printf("Rear element: %s\n", rearStr);
                                }
                                break;
                            case 7:
                                printf(isEmpty() ? "Deque is empty.\n" : "Deque is not empty.\n");
                                break;
                            case 8:
                                printf(isFull() ? "Deque is full.\n" : "Deque is not full.\n");
                                break;
                            case 9:
                                for (int i = front; i <= rear; i++) {
                                    free(deque[i]);
                                }
                                free(deque);
                                return 0;
                            default:
                                printf("Invalid choice. Please enter a valid option.\n");
                        }
                    }
                
                    for (int i = front; i <= rear; i++) {
                        free(deque[i]);
                    }
                    free(deque);
                    return 0;
                }
                
        
            </code></pre>
            <h3>Output</h3>
            <pre><code> 

                Double Ended Queue (Deque) Operations:
                1. Insert at Front
                2. Insert at Rear
                3. Delete from Front
                4. Delete from Rear
                5. Peek at Front
                6. Peek at Rear
                7. Is Empty
                8. Is Full
                9. Exit
                Enter your choice: 1
                Enter a string to insert at the front: S
                Inserted at the front: S
                
                Double Ended Queue (Deque) Operations:
                1. Insert at Front
                2. Insert at Rear
                3. Delete from Front
                4. Delete from Rear
                5. Peek at Front
                6. Peek at Rear
                7. Is Empty
                8. Is Full
                9. Exit
                Enter your choice: 2
                Enter a string to insert at the rear: G
                Inserted at the rear: G
                
                Double Ended Queue (Deque) Operations:
                1. Insert at Front
                2. Insert at Rear
                3. Delete from Front
                4. Delete from Rear
                5. Peek at Front
                6. Peek at Rear
                7. Is Empty
                8. Is Full
                9. Exit
                Enter your choice: 1
                Enter a string to insert at the front: R
                Inserted at the front: R
                
                Double Ended Queue (Deque) Operations:
                1. Insert at Front
                2. Insert at Rear
                3. Delete from Front
                4. Delete from Rear
                5. Peek at Front
                6. Peek at Rear
                7. Is Empty
                8. Is Full
                9. Exit
                Enter your choice: 4
                Deleted from the rear: G
                
                Double Ended Queue (Deque) Operations:
                1. Insert at Front
                2. Insert at Rear
                3. Delete from Front
                4. Delete from Rear
                5. Peek at Front
                6. Peek at Rear
                7. Is Empty
                8. Is Full
                9. Exit
                Enter your choice: 6
                Rear element: 
            </code></pre>
        </section>
        <section id="">
            <h2>11. Implement the Operations of Priority Queue Dynamically of Integers (Insert, Delete, Peek, Isempty, Isfull)
            </h2>
            <pre><code>
                #include 
                #include 
                
                struct PriorityQueue {
                    int capacity;
                    int size;
                    int* elements;
                };
                
                struct PriorityQueue* createPriorityQueue(int capacity) {
                    struct PriorityQueue* pq = (struct PriorityQueue*)malloc(sizeof(struct PriorityQueue));
                    if (pq == NULL) {
                        printf("Memory allocation failed.\n");
                        exit(1);
                    }
                    pq->capacity = capacity;
                    pq->size = 0;
                    pq->elements = (int*)malloc(sizeof(int) * capacity);
                    return pq;
                }
                
                // Helper function to swap two integers
                void swap(int* a, int* b) {
                    int temp = *a;
                    *a = *b;
                    *b = temp;
                }
                
                // Function to check if the priority queue is empty
                int isEmpty(struct PriorityQueue* pq) {
                    return pq->size == 0;
                }
                
                // Function to check if the priority queue is full
                int isFull(struct PriorityQueue* pq) {
                    return pq->size == pq->capacity;
                }
                
                // Function to insert an element into the priority queue
                void insert(struct PriorityQueue* pq, int item) {
                    if (isFull(pq)) {
                        printf("Priority Queue is full. Cannot insert.\n");
                        return;
                    }
                    pq->size++;
                    int i = pq->size - 1;
                    pq->elements[i] = item;
                
                    // Fix the max heap property
                    while (i > 0 && pq->elements[(i - 1) / 2] < pq->elements[i]) {
                        swap(&pq->elements[i], &pq->elements[(i - 1) / 2]);
                        i = (i - 1) / 2;
                    }
                
                    printf("Inserted: %d\n", item);
                }
                
                // Function to delete the element with the highest priority
                int delete(struct PriorityQueue* pq) {
                    if (isEmpty(pq)) {
                        printf("Priority Queue is empty. Cannot delete.\n");
                        return -1;
                    }
                    if (pq->size == 1) {
                        pq->size--;
                        return pq->elements[0];
                    }
                    int root = pq->elements[0];
                    pq->elements[0] = pq->elements[pq->size - 1];
                    pq->size--;
                
                    // Fix the max heap property
                    int i = 0;
                    while (1) {
                        int left = 2 * i + 1;
                        int right = 2 * i + 2;
                        int largest = i;
                
                        if (left < pq->size && pq->elements[left] > pq->elements[largest])
                            largest = left;
                
                        if (right < pq->size && pq->elements[right] > pq->elements[largest])
                            largest = right;
                
                        if (largest != i) {
                            swap(&pq->elements[i], &pq->elements[largest]);
                            i = largest;
                        } else {
                            break;
                        }
                    }
                
                    return root;
                }
                
                // Function to peek at the highest-priority element
                int peek(struct PriorityQueue* pq) {
                    if (isEmpty(pq)) {
                        printf("Priority Queue is empty. Cannot peek.\n");
                        return -1;
                    }
                    return pq->elements[0];
                }
                
                int main() {
                    int capacity;
                    printf("Enter the capacity of the Priority Queue: ");
                    scanf("%d", &capacity);
                
                    struct PriorityQueue* pq = createPriorityQueue(capacity);
                
                    int choice, item;
                
                    while (1) {
                        printf("\nPriority Queue Operations:\n");
                        printf("1. Insert\n");
                        printf("2. Delete\n");
                        printf("3. Peek\n");
                        printf("4. Is Empty\n");
                        printf("5. Is Full\n");
                        printf("6. Exit\n");
                        printf("Enter your choice: ");
                        scanf("%d", &choice);
                
                        switch (choice) {
                            case 1:
                                printf("Enter element to insert: ");
                                scanf("%d", &item);
                                insert(pq, item);
                                break;
                            case 2:
                                item = delete(pq);
                                if (item != -1) {
                                    printf("Deleted: %d\n", item);
                                }
                                break;
                            case 3:
                                item = peek(pq);
                                if (item != -1) {
                                    printf("Highest-priority element: %d\n", item);
                                }
                                break;
                            case 4:
                                printf(isEmpty(pq) ? "Priority Queue is empty.\n" : "Priority Queue is not empty.\n");
                                break;
                            case 5:
                                printf(isFull(pq) ? "Priority Queue is full.\n" : "Priority Queue is not full.\n");
                                break;
                            case 6:
                                free(pq->elements);
                                free(pq);
                                return 0;
                            default:
                                printf("Invalid choice. Please enter a valid option.\n");
                        }
                    }
                
                    free(pq->elements);
                    free(pq);
                    return 0;
                }
                
            </code></pre>
            <h3>Output</h3>
            <pre><code> 
                Enter the capacity of the Priority Queue: 4
                Priority Queue Operations:
                1. Insert
                2. Delete
                3. Peek
                4. Is Empty
                5. Is Full
                6. Exit
                Enter your choice: 1
                Enter element to insert: 20
                Inserted: 20
                Priority Queue Operations:
                1. Insert
                2. Delete
                3. Peek
                4. Is Empty
                5. Is Full
                6. Exit
                Enter your choice: 1
                Enter element to insert: 22
                Inserted: 22
                
                Priority Queue Operations:
                1. Insert
                2. Delete
                3. Peek
                4. Is Empty
                5. Is Full
                6. Exit
                Enter your choice: 1
                Enter element to insert: 15
                Inserted: 15
                
                Priority Queue Operations:
                1. Insert
                2. Delete
                3. Peek
                4. Is Empty
                5. Is Full
                6. Exit
                Enter your choice: 1
                Enter element to insert: 10
                Inserted: 10
                
                Priority Queue Operations:
                1. Insert
                2. Delete
                3. Peek
                4. Is Empty
                5. Is Full
                6. Exit
                Enter your choice: 3
                Highest-priority element: 22
                
                Priority Queue Operations:
                1. Insert
                2. Delete
                3. Peek
                4. Is Empty
                5. Is Full
                6. Exit
                Enter your choice: 5
                Priority Queue is full.
                
                Priority Queue Operations:
                1. Insert
                2. Delete
                3. Peek
                4. Is Empty
                5. Is Full
                6. Exit
                Enter your choice: 4
                Priority Queue is not empty.
                
                Priority Queue Operations:
                1. Insert
                2. Delete
                3. Peek
                4. Is Empty
                5. Is Full
                6. Exit
                Enter your choice: 6
                
            
            </code></pre>
        </section>
        <section id="">
            <h2>12. Implement the Operations of Priority Queue Dynamically of String (Insert, Delete, Peek, Isempty, Isfull)
            </h2>
            <pre><code>
                #include 
                #include 
                #include 
                
                struct PriorityQueue {
                    int capacity;
                    int size;
                    char** elements;
                };
                
                struct PriorityQueue* createPriorityQueue(int capacity) {
                    struct PriorityQueue* pq = (struct PriorityQueue*)malloc(sizeof(struct PriorityQueue));
                    if (pq == NULL) {
                        printf("Memory allocation failed.\n");
                        exit(1);
                    }
                    pq->capacity = capacity;
                    pq->size = 0;
                    pq->elements = (char**)malloc(sizeof(char*) * capacity);
                    return pq;
                }
                
                // Function to check if the priority queue is empty
                int isEmpty(struct PriorityQueue* pq) {
                    return pq->size == 0;
                }
                
                // Function to check if the priority queue is full
                int isFull(struct PriorityQueue* pq) {
                    return pq->size == pq->capacity;
                }
                
                // Function to insert a string into the priority queue
                void insert(struct PriorityQueue* pq, char* item) {
                    if (isFull(pq)) {
                        printf("Priority Queue is full. Cannot insert.\n");
                        return;
                    }
                    pq->elements[pq->size] = strdup(item); // Duplicate the input string
                    pq->size++;
                
                    // Build a max heap
                    int current = pq->size - 1;
                    int parent = (current - 1) / 2;
                    while (current > 0 && strcmp(pq->elements[current], pq->elements[parent]) > 0) {
                        char* temp = pq->elements[current];
                        pq->elements[current] = pq->elements[parent];
                        pq->elements[parent] = temp;
                
                        current = parent;
                        parent = (current - 1) / 2;
                    }
                
                    printf("Inserted: %s\n", item);
                }
                
                // Function to delete the element with the highest priority
                char* delete(struct PriorityQueue* pq) {
                    if (isEmpty(pq)) {
                        printf("Priority Queue is empty. Cannot delete.\n");
                        return NULL;
                    }
                    char* root = pq->elements[0];
                    pq->size--;
                
                    // Move the last element to the root
                    pq->elements[0] = pq->elements[pq->size];
                    // Free the last element to avoid memory leaks
                    free(pq->elements[pq->size]);
                
                    // Build the max heap again
                    int current = 0;
                    while (1) {
                        int left = 2 * current + 1;
                        int right = 2 * current + 2;
                        int largest = current;
                
                        if (left < pq->size && strcmp(pq->elements[left], pq->elements[largest]) > 0) {
                            largest = left;
                        }
                
                        if (right < pq->size && strcmp(pq->elements[right], pq->elements[largest]) > 0) {
                            largest = right;
                        }
                
                        if (largest != current) {
                            char* temp = pq->elements[current];
                            pq->elements[current] = pq->elements[largest];
                            pq->elements[largest] = temp;
                
                            current = largest;
                        } else {
                            break;
                        }
                    }
                
                    return root;
                }
                
                // Function to peek at the highest-priority element
                char* peek(struct PriorityQueue* pq) {
                    if (isEmpty(pq)) {
                        printf("Priority Queue is empty. Cannot peek.\n");
                        return NULL;
                    }
                    return pq->elements[0];
                }
                
                int main() {
                    int capacity;
                    printf("Enter the capacity of the Priority Queue: ");
                    scanf("%d", &capacity);
                
                    struct PriorityQueue* pq = createPriorityQueue(capacity);
                
                    int choice;
                    char input[100];
                
                    while (1) {
                        printf("\nPriority Queue Operations:\n");
                        printf("1. Insert\n");
                        printf("2. Delete\n");
                        printf("3. Peek\n");
                        printf("4. Is Empty\n");
                        printf("5. Is Full\n");
                        printf("6. Exit\n");
                        printf("Enter your choice: ");
                        scanf("%d", &choice);
                
                        switch (choice) {
                            case 1:
                                printf("Enter a string to insert: ");
                                scanf("%s", input);
                                insert(pq, input);
                                break;
                            case 2:
                                char* deleted = delete(pq);
                                if (deleted != NULL) {
                                    printf("Deleted: %s\n", deleted);
                                    free(deleted); // Free the deleted element to avoid memory leaks
                                }
                                break;
                            case 3:
                                char* front = peek(pq);
                                if (front != NULL) {
                                    printf("Highest-priority element: %s\n", front);
                                }
                                break;
                            case 4:
                                printf(isEmpty(pq) ? "Priority Queue is empty.\n" : "Priority Queue is not empty.\n");
                                break;
                            case 5:
                                printf(isFull(pq) ? "Priority Queue is full.\n" : "Priority Queue is not full.\n");
                                break;
                            case 6:
                                for (int i = 0; i < pq->size; i++) {
                                    free(pq->elements[i]); // Free all remaining elements
                                }
                                free(pq->elements);
                                free(pq);
                                return 0;
                            default:
                                printf("Invalid choice. Please enter a valid option.\n");
                        }
                    }
                
                    for (int i = 0; i < pq->size; i++) {
                        free(pq->elements[i]); // Free all remaining elements
                    }
                    free(pq->elements);
                    free(pq);
                    return 0;
                }
              
            </code></pre>
            <h3>Output</h3>
            <pre><code> 
                Enter the capacity of the Priority Queue: 4
                Priority Queue Operations:
                1. Insert
                2. Delete
                3. Peek
                4. Is Empty
                5. Is Full
                6. Exit
                Enter your choice: 1
                Enter a string to insert: Cat
                Inserted: Cat
                
                Priority Queue Operations:
                1. Insert
                2. Delete
                3. Peek
                4. Is Empty
                5. Is Full
                6. Exit
                Enter your choice: 1
                Enter a string to insert: Dog
                Inserted: Dog
                
                Priority Queue Operations:
                1. Insert
                2. Delete
                3. Peek
                4. Is Empty
                5. Is Full
                6. Exit
                Enter your choice: 1
                Enter a string to insert: Pig
                Inserted: Pig
                
                Priority Queue Operations:
                1. Insert
                2. Delete
                3. Peek
                4. Is Empty
                5. Is Full
                6. Exit
                Enter your choice: 1
                Enter a string to insert: Hen
                Inserted: Hen
                
                Priority Queue Operations:
                1. Insert
                2. Delete
                3. Peek
                4. Is Empty
                5. Is Full
                6. Exit
                Enter your choice: 4
                Priority Queue is not empty.
                
                Priority Queue Operations:
                1. Insert
                2. Delete
                3. Peek
                4. Is Empty
                5. Is Full
                6. Exit
                Enter your choice: 5
                Priority Queue is full.
                
                Priority Queue Operations:
                1. Insert
                2. Delete
                3. Peek
                4. Is Empty
                5. Is Full
                6. Exit
                Enter your choice: 3
                Highest-priority element: Pig
                
            </code></pre>
        </section>
        <section id="">
            <h2>13. Find the first circular tour that visits all petrol pumps

                Explanation -
                
                Given information about N petrol pumps (say arr[]) that are present in a circular path. The information consists of the distance of the next petrol pump from the current one (in arr[i][1]) and the amount of petrol stored in that petrol pump (in arr[i][0]). Consider a truck with infinite capacity that consumes 1 unit of petrol to travel 1 unit distance. The task is to find the index of the first starting point such that the truck can visit all the petrol pumps and come back to that starting point. Note: Return -1 if no such tour exists. Examples: Input: arr[] = {{4, 6}, {6, 5}, {7, 3}, {4, 5}}. Output: 1 Explanation: If started
                 from 1st index then a circular tour can be covered. Input: arr[] {{6, 4}, {3, 6}, {7, 3}} Output: 2</h2>
            <pre><code>
                #include <stdio.h>

                    int tour(int arr[][2], int n) {
                        int start = 0, end = 1;
                        int petrol = arr[start][0] - arr[start][1];
                    
                        while (end != start || petrol < 0) {
                            while (petrol < 0 && start != end) {
                                petrol -= arr[start][0] - arr[start][1];
                                start = (start + 1) % n;
                    
                                if (start == 0)
                                    return -1;
                            }
                    
                            petrol += arr[end][0] - arr[end][1];
                            end = (end + 1) % n;
                        }
                    
                        return start;
                    }
                    
                    int main() {
                        int n;
                        printf("Enter the number of petrol pumps: ");
                        scanf("%d", &n);
                    
                        int arr[n][2];
                    
                        printf("Enter the petrol and distance for each petrol pump:\n");
                        for (int i = 0; i < n; ++i) {
                            printf("Petrol pump %d: ", i + 1);
                            scanf("%d %d", &arr[i][0], &arr[i][1]);
                        }
                    
                        int result = tour(arr, n);
                    
                        if (result == -1)
                            printf("No solution exists.");
                        else
                            printf("Starting point: %d", result);
                    
                        return 0;
                    }
                    
            </code></pre>
            <h3>Output</h3>
            <pre><code> 
                Enter the number of petrol pumps: 4
                Enter the petrol and distance for each petrol pump:
                Petrol pump 1: 4 6
                Petrol pump 2: 6 5
                Petrol pump 3: 7 3
                Petrol pump 4: 4 5
                Starting point: 1
                
            </code></pre>
        </section>
        <section id="">
            <h2>14. Length of the longest valid substring

                Explanation -
                
                Given a string consisting of opening and closing parenthesis, find the length of the longest 
                valid parenthesis substring. Examples: Input : ((() Output : 2 Explanation : 
                () Input: )()()) Output : 4 Explanation: ()() Input: ()(())))) Output: 6 Explanation: ()(())</h2>
            <pre><code>
                #include <stdio.h>
                    #include <string.h>
                    #include <stdlib.h>
                    
                    // Function to find the length of the longest valid parenthesis substring
                    int longestValidSubstring(char* s) {
                        int n = strlen(s);
                        int* stack = (int*)malloc(n * sizeof(int)); // Stack to store indices of opening parentheses
                        int top = -1; // Top of the stack
                        int maxLen = 0; // Maximum length of valid substring
                    
                        // Initialize the stack with -1
                        stack[++top] = -1;
                    
                        // Traverse the string
                        for (int i = 0; i < n; i++) {
                            // If the current character is an opening parenthesis, push its index onto the stack
                            if (s[i] == '(') {
                                stack[++top] = i;
                            } else {
                                // If the current character is a closing parenthesis
                                if (top != -1) {
                                    // Pop the top element from the stack (matching opening parenthesis)
                                    top--;
                    
                                    // Check if the stack is not empty
                                    if (top != -1) {
                                        // Calculate the length of the current valid substring
                                        int len = i - stack[top];
                    
                                        // Update the maximum length if the current length is greater
                                        if (len > maxLen) {
                                            maxLen = len;
                                        }
                                    } else {
                                        // If the stack is empty, push the current index onto the stack
                                        stack[++top] = i;
                                    }
                                } else {
                                    // If the stack is empty, push the current index onto the stack
                                    stack[++top] = i;
                                }
                            }
                        }
                    
                        // Return the maximum length of valid substring
                        free(stack);
                        return maxLen;
                    }
                    
                    int main() {
                        char input[100];
                    
                        // Get the input string
                        printf("Enter the string: ");
                        scanf("%s", input);
                    
                        // Find the length of the longest valid parenthesis substring
                        int result = longestValidSubstring(input);
                    
                        // Print the result
                        printf("Length of the longest valid parenthesis substring: %d\n", result);
                    
                        return 0;
                    }
                    
            </code></pre>
            <h3>Output</h3>
            <pre><code> 
                Enter the string: (vikkas)
                Length of the longest valid parenthesis substring: 2
                
            </code></pre>
        </section>
        <section id="">
            <h2>15. Find the Next Greater Element

                Explanation -
                
                Given an array arr[ ] of size N having elements, the task is to 
                find the next greater element for each element of the array in order of their 
                appearance in the array. Next greater element of an element in the array is the nearest
                 element on the right which is greater than the current element. If there does not exist 
                 next greater of current element, then next greater element for current element is -1. For example, next greater of the last element is always -1. Example 1: Input: N = 4, arr[] = [1 3 2 4] Output: 3 4 4 -1 Explanation: In the array, the next larger element to 1 is 3 , 3 is 4 , 2 is 4 and for 4 ? since it doesn't exist, it is -1. Example 2: Input: N = 5, arr[] [6 8 0 1 3] Output: 8 -1 1 3 -1 Explanation: In the array, the next larger element to 6 is 8, for 8 there is no larger elements hence it is -1, for 0 it is 1 , for 1 it is 3 and then for 3 there is no larger element on right and hence -1.</h2>
            <pre><code>
                #include <stdio.h>
                    #include <stdlib.h>
                    
                    // Structure to represent a stack
                    struct Stack {
                        int capacity;
                        int top;
                        int* array;
                    };
                    
                    // Function to create a stack
                    struct Stack* createStack(int capacity) {
                        struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));
                        stack->capacity = capacity;
                        stack->top = -1;
                        stack->array = (int*)malloc(stack->capacity * sizeof(int));
                        return stack;
                    }
                    
                    // Function to check if the stack is empty
                    int isEmpty(struct Stack* stack) {
                        return stack->top == -1;
                    }
                    
                    // Function to push an element onto the stack
                    void push(struct Stack* stack, int item) {
                        stack->array[++stack->top] = item;
                    }
                    
                    // Function to pop an element from the stack
                    int pop(struct Stack* stack) {
                        if (isEmpty(stack))
                            return -1;
                        return stack->array[stack->top--];
                    }
                    
                    // Function to find the next greater element for each element in the array
                    void nextGreaterElement(int arr[], int N) {
                        struct Stack* stack = createStack(N);
                        int result[N];
                    
                        // Traverse the array from right to left
                        for (int i = N - 1; i >= 0; i--) {
                            // Pop elements from the stack while the stack is not empty and the current element is greater than the top of the stack
                            while (!isEmpty(stack) && arr[i] >= stack->array[stack->top]) {
                                pop(stack);
                            }
                    
                            // If the stack is empty, there is no greater element to the right
                            if (isEmpty(stack)) {
                                result[i] = -1;
                            } else {
                                // The next greater element is the top of the stack
                                result[i] = stack->array[stack->top];
                            }
                    
                            // Push the current element onto the stack
                            push(stack, arr[i]);
                        }
                    
                        // Print the result
                        printf("Next Greater Elements: ");
                        for (int i = 0; i < N; i++) {
                            printf("%d ", result[i]);
                        }
                        printf("\n");
                    
                        // Free the memory used by the stack
                        free(stack->array);
                        free(stack);
                    }
                    
                    int main() {
                        int N;
                    
                        // Get the number of elements in the array
                        printf("Enter the number of elements in the array: ");
                        scanf("%d", &N);
                    
                        int arr[N];
                    
                        // Get the elements of the array
                        printf("Enter the elements of the array:\n");
                        for (int i = 0; i < N; i++) {
                            scanf("%d", &arr[i]);
                        }
                    
                        // Find the next greater element for each element in the array
                        nextGreaterElement(arr, N);
                    
                        return 0;
                    }
                    
            </code></pre>
            <h3>Output</h3>
            <pre><code> 
                Enter the number of elements in the array: 4
                Enter the elements of the array:
                87
                98
                67
                54
                Next Greater Elements: 98 -1 -1 -1 
                
            </code></pre>
        </section>
        <section id="">
            <h2>16. Find Next Smaller Element

                Explanation -
                
                Given an array, print the Next Smaller Element (NSE) for every element. The NSE for an
                 element x is the first smaller element on the right side of x in the array. Elements for which no smaller element exist (on the right side), consider NSE as -1. Examples: Input: [4, 8, 5, 2, 25] Output: [2, 5, 2, -1, -1] Explanation: The first element smaller than 4 having index > 0 is 2. The first element smaller than 8 having index > 1 is 5. The first element smaller than 5 having index > 2 is 2. There are no elements smaller than 4 having index > 3. There are no elements smaller than 4 having index > 4. Input: [13, 7, 6, 12] Output: [7, 6, -1, -1] Explanation: The first element smaller than 13 having index > 0 is 7. The first element smaller than 7 having index > 1 is 6. There are no
                 elements smaller than 6 having index > 2. There are no elements smaller than 12 having index > 3.</h2>
            <pre><code>
                #include <stdio.h>
                    #include <stdlib.h>
                    
                    // Structure to represent a stack
                    struct Stack {
                        int capacity;
                        int top;
                        int* array;
                    };
                    
                    // Function to create a stack
                    struct Stack* createStack(int capacity) {
                        struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));
                        stack->capacity = capacity;
                        stack->top = -1;
                        stack->array = (int*)malloc(stack->capacity * sizeof(int));
                        return stack;
                    }
                    
                    // Function to check if the stack is empty
                    int isEmpty(struct Stack* stack) {
                        return stack->top == -1;
                    }
                    
                    // Function to push an element onto the stack
                    void push(struct Stack* stack, int item) {
                        stack->array[++stack->top] = item;
                    }
                    
                    // Function to pop an element from the stack
                    int pop(struct Stack* stack) {
                        if (isEmpty(stack))
                            return -1;
                        return stack->array[stack->top--];
                    }
                    
                    // Function to find the next smaller element for each element in the array
                    void nextSmallerElement(int arr[], int N) {
                        struct Stack* stack = createStack(N);
                        int result[N];
                    
                        // Traverse the array from right to left
                        for (int i = N - 1; i >= 0; i--) {
                            // Pop elements from the stack while the stack is not empty and the current element is smaller than the top of the stack
                            while (!isEmpty(stack) && arr[i] < stack->array[stack->top]) {
                                pop(stack);
                            }
                    
                            // If the stack is empty, there is no smaller element to the right
                            if (isEmpty(stack)) {
                                result[i] = -1;
                            } else {
                                // The next smaller element is the top of the stack
                                result[i] = stack->array[stack->top];
                            }
                    
                            // Push the current element onto the stack
                            push(stack, arr[i]);
                        }
                    
                        // Print the result
                        printf("Next Smaller Elements: ");
                        for (int i = 0; i < N; i++) {
                            printf("%d ", result[i]);
                        }
                        printf("\n");
                    
                        // Free the memory used by the stack
                        free(stack->array);
                        free(stack);
                    }
                    
                    int main() {
                        int N;
                    
                        // Get the number of elements in the array
                        printf("Enter the number of elements in the array: ");
                        scanf("%d", &N);
                    
                        int arr[N];
                    
                        // Get the elements of the array
                        printf("Enter the elements of the array:\n");
                        for (int i = 0; i < N; i++) {
                            scanf("%d", &arr[i]);
                        }
                    
                        // Find the next smaller element for each element in the array
                        nextSmallerElement(arr, N);
                    
                        return 0;
                    }
                    
            </code></pre>
            <h3>Output</h3>
            <pre><code> 
                Enter the number of elements in the array: 
                4
                Enter the elements of the array:
                5
                6
                11
                12
                Next Smaller Elements: 2 2 2 -1
            </code></pre>
        </section>
        <section id="">
            <h2>17. Queue based approach for first non-repeating character in a stream

                Explanation -
                
                Given a stream of characters and we have to find first non repeating character each time a character is 
                inserted to the stream. Examples: Input : a a b c Output : a -1 b b Input : a a c Output : a -1 c</h2>
            <pre><code>
                #include <stdio.h>
                    #include <stdlib.h>
                    
                    // Structure to represent a queue node
                    struct QueueNode {
                        char data;
                        struct QueueNode* next;
                    };
                    
                    // Structure to represent a queue
                    struct Queue {
                        struct QueueNode *front, *rear;
                    };
                    
                    // Function to create a new queue node
                    struct QueueNode* createQueueNode(char data) {
                        struct QueueNode* newNode = (struct QueueNode*)malloc(sizeof(struct QueueNode));
                        newNode->data = data;
                        newNode->next = NULL;
                        return newNode;
                    }
                    
                    // Function to create a new queue
                    struct Queue* createQueue() {
                        struct Queue* queue = (struct Queue*)malloc(sizeof(struct Queue));
                        queue->front = queue->rear = NULL;
                        return queue;
                    }
                    
                    // Function to enqueue a character
                    void enqueue(struct Queue* queue, char data) {
                        struct QueueNode* newNode = createQueueNode(data);
                        if (queue->rear == NULL) {
                            queue->front = queue->rear = newNode;
                            return;
                        }
                        queue->rear->next = newNode;
                        queue->rear = newNode;
                    }
                    
                    // Function to dequeue a character
                    char dequeue(struct Queue* queue) {
                        if (queue->front == NULL)
                            return '\0';
                        char data = queue->front->data;
                        struct QueueNode* temp = queue->front;
                        queue->front = queue->front->next;
                        if (queue->front == NULL)
                            queue->rear = NULL;
                        free(temp);
                        return data;
                    }
                    
                    // Function to check if the queue is empty
                    int isEmpty(struct Queue* queue) {
                        return queue->front == NULL;
                    }
                    
                    // Function to find the first non-repeating character in the stream
                    void firstNonRepeating(char stream[], int n) {
                        struct Queue* queue = createQueue();
                        int count[256] = {0}; // Array to store the frequency of each character
                        char result[n];
                    
                        for (int i = 0; i < n; i++) {
                            char currentChar = stream[i];
                    
                            // Enqueue the current character
                            enqueue(queue, currentChar);
                    
                            // Increment the frequency of the current character
                            count[currentChar]++;
                    
                            // Check if the front of the queue is a non-repeating character
                            while (!isEmpty(queue) && count[queue->front->data] > 1) {
                                dequeue(queue);
                            }
                    
                            // If the queue is not empty, the front of the queue is the first non-repeating character
                            if (!isEmpty(queue)) {
                                result[i] = queue->front->data;
                            } else {
                                result[i] = -1; // No non-repeating character found
                            }
                        }
                    
                        // Print the result
                        printf("First Non-Repeating Characters: ");
                        for (int i = 0; i < n; i++) {
                            if (result[i] == -1) {
                                printf("-1 ");
                            } else {
                                printf("%c ", result[i]);
                            }
                        }
                        printf("\n");
                    
                        // Free the memory used by the queue
                        while (!isEmpty(queue)) {
                            dequeue(queue);
                        }
                        free(queue);
                    }
                    
                    int main() {
                        char stream[] = {'a', 'a', 'b', 'c'};
                        int n = sizeof(stream) / sizeof(stream[0]);
                    
                        // Find the first non-repeating character in the stream
                        firstNonRepeating(stream, n);
                    
                        return 0;
                    }
                    
            </code></pre>
            <h3>Output</h3>
            <pre><code> 
                First Non-Repeating Characters: a -1 b b 
                h
                    
            </code></pre>
        </section>
        <section id="">
            <h2>18. Reverse First K elements of Queue

                Explanation -
                
                Given an integer K and a queue of integers, we need to reverse the order of the first K elements of the queue, leaving the other elements in the same relative order. Only following standard operations are allowed on queue. enqueue(x) : Add an item x to rear of queue dequeue() : Remove an item from front of queue size() : Returns number of elements in queue. front() : Finds front item. Note: The above operations represent the general processings. In-built functions of the respective languages can be used to solve the problem. Example 1: Input: 5 3 1 2 3 4 5 Output: 3 2 1 4 5 Explanation: After reversing the given input from the 3rd position the resultant output will be 3 2 1 4 5. Example 2: Input: 4 4 4 3 2 1 Output: 1 2 3 4 
                Explanation: After reversing the given input from the 4th position the resultant output will be 1 2 3 4.</h2>
            <pre><code>
                #include <stdio.h>
                    #include <stdlib.h>
                    
                    // Structure to represent a queue node
                    struct QueueNode {
                        int data;
                        struct QueueNode* next;
                    };
                    
                    // Structure to represent a queue
                    struct Queue {
                        struct QueueNode *front, *rear;
                    };
                    
                    // Function to create a new queue node
                    struct QueueNode* createQueueNode(int data) {
                        struct QueueNode* newNode = (struct QueueNode*)malloc(sizeof(struct QueueNode));
                        newNode->data = data;
                        newNode->next = NULL;
                        return newNode;
                    }
                    
                    // Function to create a new queue
                    struct Queue* createQueue() {
                        struct Queue* queue = (struct Queue*)malloc(sizeof(struct Queue));
                        queue->front = queue->rear = NULL;
                        return queue;
                    }
                    
                    // Function to enqueue an element
                    void enqueue(struct Queue* queue, int data) {
                        struct QueueNode* newNode = createQueueNode(data);
                        if (queue->rear == NULL) {
                            queue->front = queue->rear = newNode;
                            return;
                        }
                        queue->rear->next = newNode;
                        queue->rear = newNode;
                    }
                    
                    // Function to dequeue an element
                    int dequeue(struct Queue* queue) {
                        if (queue->front == NULL)
                            return -1;
                        int data = queue->front->data;
                        struct QueueNode* temp = queue->front;
                        queue->front = queue->front->next;
                        if (queue->front == NULL)
                            queue->rear = NULL;
                        free(temp);
                        return data;
                    }
                    
                    // Function to check if the queue is empty
                    int isEmpty(struct Queue* queue) {
                        return queue->front == NULL;
                    }
                    
                    // Function to reverse the first K elements of the queue
                    void reverseFirstK(struct Queue* queue, int k) {
                        if (k <= 0 || k > size(queue))
                            return;
                    
                        struct QueueNode* temp[k];
                        struct Queue* reverseQueue = createQueue();
                    
                        // Dequeue the first K elements and push them onto a stack
                        for (int i = 0; i < k; i++) {
                            temp[i] = createQueueNode(dequeue(queue));
                        }
                    
                        // Enqueue the reversed K elements into a new queue
                        for (int i = k - 1; i >= 0; i--) {
                            enqueue(reverseQueue, temp[i]->data);
                        }
                    
                        // Enqueue the remaining elements from the original queue
                        while (!isEmpty(queue)) {
                            enqueue(reverseQueue, dequeue(queue));
                        }
                    
                        // Copy the reversed queue back to the original queue
                        while (!isEmpty(reverseQueue)) {
                            enqueue(queue, dequeue(reverseQueue));
                        }
                    
                        // Free the memory used by the temporary stack and queue
                        for (int i = 0; i < k; i++) {
                            free(temp[i]);
                        }
                        free(reverseQueue);
                    }
                    
                    // Function to calculate the size of the queue
                    int size(struct Queue* queue) {
                        int count = 0;
                        struct QueueNode* current = queue->front;
                        while (current != NULL) {
                            count++;
                            current = current->next;
                        }
                        return count;
                    }
                    
                    // Function to print the elements of the queue
                    void printQueue(struct Queue* queue) {
                        struct QueueNode* current = queue->front;
                        while (current != NULL) {
                            printf("%d ", current->data);
                            current = current->next;
                        }
                        printf("\n");
                    }
                    
                    int main() {
                        struct Queue* queue = createQueue();
                    
                        // Input example
                        int k = 3;
                        enqueue(queue, 1);
                        enqueue(queue, 2);
                        enqueue(queue, 3);
                        enqueue(queue, 4);
                        enqueue(queue, 5);
                    
                        // Reverse the first K elements
                        reverseFirstK(queue, k);
                    
                        // Output
                        printQueue(queue);
                    
                        // Free the memory used by the queue
                        free(queue);
                    
                        return 0;
                    }
                    
            </code></pre>
            <h3>Output</h3>
            <pre><code> 
                Input: k = 3, Queue: 1 2 3 4 5
                Output: 3 2 1 4 5
            </code></pre>
        </section>
        <section id="">
            <h2>19. Queue Reversal
                  Explanation -
                 Given a Queue Q containing N elements. The task is to reverse the Queue. Your task is to complete the function rev(), that reverses the N elements of the queue. Example 1: Input: 6 4 3 1 10 2 6 Output: 6 2 10 1 3 4 Explanation: After reversing the given elements of the queue , the resultant queue will be 6 2 10 1 3 4. Example 2: Input: 4 4 3 2 1 Output: 1 2 3 4 
                Explanation: After reversing the given elements of the queue , the resultant queue will be 1 2 3 4.</h2>
            <pre><code>
                #include <stdio.h>
                    #include <stdlib.h>
                    
                    // Structure to represent a queue node
                    struct QueueNode {
                        int data;
                        struct QueueNode* next;
                    };
                    
                    // Structure to represent a queue
                    struct Queue {
                        struct QueueNode *front, *rear;
                    };
                    
                    // Structure to represent a stack node
                    struct StackNode {
                        int data;
                        struct StackNode* next;
                    };
                    
                    // Structure to represent a stack
                    struct Stack {
                        struct StackNode* top;
                    };
                    
                    // Function to create a new queue node
                    struct QueueNode* createQueueNode(int data) {
                        struct QueueNode* newNode = (struct QueueNode*)malloc(sizeof(struct QueueNode));
                        newNode->data = data;
                        newNode->next = NULL;
                        return newNode;
                    }
                    
                    // Function to create a new queue
                    struct Queue* createQueue() {
                        struct Queue* queue = (struct Queue*)malloc(sizeof(struct Queue));
                        queue->front = queue->rear = NULL;
                        return queue;
                    }
                    
                    // Function to create a new stack node
                    struct StackNode* createStackNode(int data) {
                        struct StackNode* newNode = (struct StackNode*)malloc(sizeof(struct StackNode));
                        newNode->data = data;
                        newNode->next = NULL;
                        return newNode;
                    }
                    
                    // Function to create a new stack
                    struct Stack* createStack() {
                        struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));
                        stack->top = NULL;
                        return stack;
                    }
                    
                    // Function to check if the queue is empty
                    int isEmptyQueue(struct Queue* queue) {
                        return queue->front == NULL;
                    }
                    
                    // Function to enqueue an element
                    void enqueue(struct Queue* queue, int data) {
                        struct QueueNode* newNode = createQueueNode(data);
                        if (queue->rear == NULL) {
                            queue->front = queue->rear = newNode;
                            return;
                        }
                        queue->rear->next = newNode;
                        queue->rear = newNode;
                    }
                    
                    // Function to dequeue an element
                    int dequeue(struct Queue* queue) {
                        if (isEmptyQueue(queue))
                            return -1;
                        int data = queue->front->data;
                        struct QueueNode* temp = queue->front;
                        queue->front = queue->front->next;
                        if (queue->front == NULL)
                            queue->rear = NULL;
                        free(temp);
                        return data;
                    }
                    
                    // Function to push an element onto the stack
                    void push(struct Stack* stack, int data) {
                        struct StackNode* newNode = createStackNode(data);
                        newNode->next = stack->top;
                        stack->top = newNode;
                    }
                    
                    // Function to pop an element from the stack
                    int pop(struct Stack* stack) {
                        if (stack->top == NULL)
                            return -1;
                        int data = stack->top->data;
                        struct StackNode* temp = stack->top;
                        stack->top = stack->top->next;
                        free(temp);
                        return data;
                    }
                    
                    // Function to reverse the queue
                    void rev(struct Queue* queue) {
                        struct Stack* stack = createStack();
                    
                        // Push elements of the queue onto the stack
                        while (!isEmptyQueue(queue)) {
                            push(stack, dequeue(queue));
                        }
                    
                        // Pop elements from the stack and enqueue them back into the queue
                        while (stack->top != NULL) {
                            enqueue(queue, pop(stack));
                        }
                    
                        // Free the memory used by the stack
                        free(stack);
                    }
                    
                    // Function to print the elements of the queue
                    void printQueue(struct Queue* queue) {
                        struct QueueNode* current = queue->front;
                        while (current != NULL) {
                            printf("%d ", current->data);
                            current = current->next;
                        }
                        printf("\n");
                    }
                    
                    int main() {
                        struct Queue* queue = createQueue();
                        int n, element;
                    
                        // Input the number of elements in the queue
                        printf("Enter the number of elements in the queue: ");
                        scanf("%d", &n);
                    
                        // Input the elements of the queue
                        printf("Enter the elements of the queue:\n");
                        for (int i = 0; i < n; i++) {
                            scanf("%d", &element);
                            enqueue(queue, element);
                        }
                    
                        // Reverse the queue
                        rev(queue);
                    
                        // Output the reversed queue
                        printf("Reversed Queue: ");
                        printQueue(queue);
                    
                        // Free the memory used by the queue
                        free(queue);
                    
                        return 0;
                    }
                    
            </code></pre>
            <h3>Output</h3>
            <pre><code> 
                Enter the number of elements in the queue: 3
                Enter the elements of the queue:
                43
                21
                65
                Reversed Queue: 65 21 43 
            </code></pre>
        </section>
        <section id="">
            <h2>20. Rotten Oranges
                Explanation -
                Given a grid of dimension nxm where each cell in the grid can have values 0, 1 or 2 
                which has the following meaning: 0 : Empty cell 1 : Cells have fresh oranges 2 : Cells 
                have rotten oranges We have to determine what is the earliest time after which all the 
                oranges are rotten. A rotten orange at index [i,j] can rot other fresh orange at indexes [i-1,j], [i+1,j], [i,j-1], [i,j+1] (up, down, left and right) in unit time. Example 1: Input: grid = {{0,1,2},{0,1,2},{2,1,1}} Output: 1 Explanation: The grid is- 0 1 2 0 1 2 2 1 1 Oranges at positions (0,2), (1,2), (2,0) will rot oranges at (0,1), (1,1), (2,2) and (2,1) in unit time. Example 2: Input: grid = {{2,2,0,1}} Output: -1 Explanation: The grid is- 2 2 0 1 Oranges at (0,0) and (0,1) can't rot orange at (0,3).
                
                </h2>
            <pre><code>
                #include <stdio.h>

                    // Function to calculate the earliest time after which all oranges are rotten
                    int orangesRotting(int grid[100][100], int rows, int cols) {
                        int time = 0;
                        int freshOranges = 0;
                    
                        // Count the number of fresh oranges
                        for (int i = 0; i < rows; i++) {
                            for (int j = 0; j < cols; j++) {
                                if (grid[i][j] == 1) {
                                    freshOranges++;
                                }
                            }
                        }
                    
                        while (freshOranges > 0) {
                            int infected = 0;
                    
                            // Traverse the grid to rot fresh oranges
                            for (int i = 0; i < rows; i++) {
                                for (int j = 0; j < cols; j++) {
                                    if (grid[i][j] == 2) {
                                        // Check and rot oranges in up, down, left, right directions
                                        if (i > 0 && grid[i - 1][j] == 1) {
                                            grid[i - 1][j] = 2;
                                            freshOranges--;
                                            infected = 1;
                                        }
                                        if (i < rows - 1 && grid[i + 1][j] == 1) {
                                            grid[i + 1][j] = 2;
                                            freshOranges--;
                                            infected = 1;
                                        }
                                        if (j > 0 && grid[i][j - 1] == 1) {
                                            grid[i][j - 1] = 2;
                                            freshOranges--;
                                            infected = 1;
                                        }
                                        if (j < cols - 1 && grid[i][j + 1] == 1) {
                                            grid[i][j + 1] = 2;
                                            freshOranges--;
                                            infected = 1;
                                        }
                                    }
                                }
                            }
                    
                            // If no fresh oranges are infected in this unit of time, break
                            if (!infected) {
                                return -1;
                            }
                    
                            time++;
                        }
                    
                        return time;
                    }
                    
                    int main() {
                        int rows, cols;
                    
                        // Input the number of rows and columns
                        printf("Enter the number of rows: ");
                        scanf("%d", &rows);
                        printf("Enter the number of columns: ");
                        scanf("%d", &cols);
                    
                        int grid[100][100];
                    
                        // Input the grid of oranges
                        printf("Enter the grid of oranges (0, 1, or 2):\n");
                        for (int i = 0; i < rows; i++) {
                            for (int j = 0; j < cols; j++) {
                                scanf("%d", &grid[i][j]);
                            }
                        }
                    
                        // Calculate the earliest time after which all oranges are rotten
                        int result = orangesRotting(grid, rows, cols);
                    
                        // Output the result
                        if (result == -1) {
                            printf("All oranges cannot be rotten.\n");
                        } else {
                            printf("Earliest time after which all oranges are rotten: %d\n", result);
                        }
                    
                        return 0;
                    }
                    
            </code></pre>
            <h3>Output</h3>
            <pre><code> 
                Enter the number of rows: 3
                Enter the number of columns: 3
                Enter the grid of oranges (0, 1, or 2):
                0 1 2
                0 1 2
                2 1 1
                Earliest time after which all oranges are rotten: 1
                
            </code></pre>
        </section>
        </div>
    </body>
</html>